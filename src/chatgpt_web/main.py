import requests
import utils
import logging
from common_requests import request_headers, request_payload, request_cookies 
import json
import re

class ChatGPT:

    def __init__(self,
                 model:str = "text-davinci-002-render-sha",
                 conversation_index:int = 0,
                 user_agent:str="Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
                 ):
        self.session = requests.Session()
        self.session.headers.update(request_headers)
        self.session.cookies.update(request_cookies)
        self.conversation_endpoint = "https://chat.openai.com/backend-api/conversation"
        self.account_detail_endpoint = "https://chat.openai.com/backend-api/accounts/check"
        self.account_details_endpoint=self.account_detail_endpoint+'/v4-2023-04-27'
        self.prompt_library_endpoint ="https://chat.openai.com/backend-api/prompt_library/"
        self.previous_conversations_endpoint = "https://chat.openai.com/backend-api/conversations"
        self.session.headers['User-Agent'] = user_agent
        self.suggestions = [prompt['title'] for prompt in self.prompt_library()['items'] ] # Generated by ChatGPT
        self.conversation_metadata = self.previous_conversations(index=conversation_index)
        self.model = model
        self.last_response = {}
        self.last_response_metadata = {}

    def __generate_payload(self,prompt:str) -> dict:
        resp = utils.generate_payload(self,prompt)
        return resp
    
    def ask(self,prompt:str,stream:bool=False) -> dict:
        """Chat with ChatGPT

        Args:
            prompt (str): message to be send
            stream (bool, optional): Flag to stream response. Defaults to True.
        returns : dict {}
        """
        response = self.session.post(url=self.conversation_endpoint, json=self.__generate_payload(prompt))
        if response.ok and response.headers.get('content-type')=="text/event-stream; charset=utf-8":
            message_off = False
            for chunk in response.iter_lines(decode_unicode=True,):
                resp = json.load(re.sub('data: ','',chunk))
                if message_off:
                    # Text generation stopped
                    self.last_response_metadata = resp
                    if not stream:
                        return self.last_response
                    break
                if resp['message']['status']=='finished_successfully':
                    self.last_response = resp
                    message_off = True
                else:
                    if stream:
                        # Response to user
                        yield resp
               

        else:
            raise Exception(f"Failed to fetch response - ({response.status_code}, {response.reason} : {response.headers.get('content-type')} : {response.text}")
        
    def user_details(self,in_details:bool=True) -> dict:
        """Returns various information concerning the user

        Args:
            in_details (bool, optional): Return detailed info. Defaults to True.
        returns:
            dict : {}
```json
{
     "accounts": {
          "b8a156d7-9a30-4de3-bf40-4d88782950c1": {
               "account": {
                    "account_user_role": "account-owner",
                    "account_user_id": "user-IUW2uKHQ6bwv4bdiI8IYtjqA__b8a156d7-9a30-4de3-bf40-4d88782950c1",
                    "processor": {
                         "a001": {
                              "has_customer_object": false
                         },
                         "b001": {
                              "has_transaction_history": false
                         },
                         "c001": {
                              "has_transaction_history": false
                         }
                    },
                    "account_id": "b8a156d7-9a30-4de3-bf40-4d88782950c1",
                    "organization_id": null,
                    "is_most_recent_expired_subscription_gratis": false,
                    "has_previously_paid_subscription": false,
                    "name": null,
                    "profile_picture_id": null,
                    "profile_picture_url": null,
                    "structure": "personal",
                    "plan_type": "free",
                    "is_deactivated": false,
                    "promo_data": {}
               },
               "features": [
                    "allow_url_thread_creation",
                    "arkose_enabled",
                    "arkose_gpt_35_experiment",
                    "bizmo_settings",
                    "breeze_available",
                    "chat_preferences_available",
                    "conversation_bot_arkose",
                    "disable_team_upgrade_ui",
                    "gizmo_live",
                    "gizmo_ui",
                    "invite_referral",
                    "new_plugin_oauth_endpoint",
                    "privacy_policy_nov_2023",
                    "shareable_links",
                    "starter_prompts",
                    "user_settings_announcements"
               ],
               "entitlement": {
                    "subscription_id": null,
                    "has_active_subscription": false,
                    "subscription_plan": "chatgptfreeplan",
                    "expires_at": null
               },
               "last_active_subscription": {
                    "subscription_id": null,
                    "purchase_origin_platform": "chatgpt_not_purchased",
                    "will_renew": false
               }
          },
          "default": {
               "account": {
                    "account_user_role": "account-owner",
                    "account_user_id": "user-IUW2uKHQ6bwv4bdiI8IYtjqA__b8a156d7-9a30-4de3-bf40-xxxxxxxxxx",
                    "processor": {
                         "a001": {
                              "has_customer_object": false
                         },
                         "b001": {
                              "has_transaction_history": false
                         },
                         "c001": {
                              "has_transaction_history": false
                         }
                    },
                    "account_id": "b8a156d7-9a30-4de3-bf40-4d887829xxxx",
                    "organization_id": null,
                    "is_most_recent_expired_subscription_gratis": false,
                    "has_previously_paid_subscription": false,
                    "name": null,
                    "profile_picture_id": null,
                    "profile_picture_url": null,
                    "structure": "personal",
                    "plan_type": "free",
                    "is_deactivated": false,
                    "promo_data": {}
               },
               "features": [
                    "allow_url_thread_creation",
                    "arkose_enabled",
                    "arkose_gpt_35_experiment",
                    "bizmo_settings",
                    "breeze_available",
                    "chat_preferences_available",
                    "conversation_bot_arkose",
                    "disable_team_upgrade_ui",
                    "gizmo_live",
                    "gizmo_ui",
                    "invite_referral",
                    "new_plugin_oauth_endpoint",
                    "privacy_policy_nov_2023",
                    "shareable_links",
                    "starter_prompts",
                    "user_settings_announcements"
               ],
               "entitlement": {
                    "subscription_id": null,
                    "has_active_subscription": false,
                    "subscription_plan": "chatgptfreeplan",
                    "expires_at": null
               },
               "last_active_subscription": {
                    "subscription_id": null,
                    "purchase_origin_platform": "chatgpt_not_purchased",
                    "will_renew": false
               }
          }
     },
     "account_ordering": [
          "b8a156d7-9a30-4de3-bf40-4d88782xxxx"
     ]
}
```
        """
        resp = self.session.get(
            self.account_details_endpoint if in_details else self.account_detail_endpoint
        )
        return utils.is_json(resp,'account data')
    
    def prompt_library(self,limit:int=4,offset:int=0) -> list:
        """Generates random prompts

        Args:
            limit (int, optional): Limit suggestions. Defaults to 4.
            offset (int, optional): Offset. Defaults to 0.
        returns:
            list : []

```json
   {
    "items": [
        {
            "id": "edb56594",
            "title": "Design a database schema",
            "description": "for an online merch store",
            "prompt": "Design a database schema for an online merch store."
        },
        {
            "id": "9fa376de",
            "title": "Recommend a dish",
            "description": "to impress a date who's a picky eater",
            "prompt": "I'm going to cook for my date who claims to be a picky eater. Can you recommend me a dish that's easy to cook?"
        }
    ],
    "total": 2,
    "limit": 2,
    "offset": 1
    }
```
        """

        resp = self.session.get(
            self.prompt_library_endpoint, 
            params={'limit':limit, "offset" : offset},
        )
        return  utils.is_json(resp,'prompts')
    
    def previous_conversations(self, limit:int=28, offset:int=0,order:str="updated",index:int=False, new=False) -> list:
        """Loads previous conversations

        Args:
            limit (int, optional): Fetch this specific amount of chats. Defaults to 28.
            offset (int, optional): ``. Defaults to 0.
            order (str, optional): Sort order. Defaults to "updated".
            index (int, optional): Return items of this index
            new (bool, optional): Return only dict containing details for new conversation

        Returns:
            list: Previous conversations contained in dict

        ```json
        {
     "items": [
          {
               "id": "86f73b54-0f51-47ba-84a3-07c1e25xxxx",
               "title": "Urine Cleaning in Rome",
               "create_time": "2023-12-15T13:39:24.683876+00:00",
               "update_time": "2023-12-15T14:02:23.776574+00:00",
               "mapping": null,
               "current_node": null,
               "conversation_template_id": null,
               "gizmo_id": null,
               "is_archived": false,
               "workspace_id": null
          },
          {
               "id": "b3779121-8767-4202-9527-3058f40xxxx",
               "title": "Helpful User, Assistant",
               "create_time": "2023-12-15T12:03:30.596706+00:00",
               "update_time": "2023-12-15T13:29:05.286457+00:00",
               "mapping": null,
               "current_node": null,
               "conversation_template_id": null,
               "gizmo_id": null,
               "is_archived": false,
               "workspace_id": null
          }
     ],
     "total": 108,
     "limit": 2,
     "offset": 0,
     "has_missing_conversations": false
   }
```
               """

        resp = self.session.get(
            self.previous_conversations_endpoint,
            params={
                'limit' : 2 if new else limit,
                'offset' : offset,
                'order' : order
            }
        )
        resp = utils.is_json(resp,'conversation history')
        if new:
            index = 0
        if isinstance(index, int):
            conversations = resp['items']
            conversations.reverse()
            if len(conversations)-1 >= index:
                return conversations[index]
            else:
                raise Exception(
                    f"Index '{index} is greater the total conversations '{len(conversations)}"
                )

        return resp
    
def write_data(path, data):
    """Echoes dict data to a file"""
    logging.info("Writing data")
    with open(path, "w") as fh:
        json.dump(data, fh, indent=5)

if __name__=='__main__':
    import json
    bot = ChatGPT(conversation_index=1)
    #resp = bot.prompt_library(limit=4)
    #resp = bot.previous_conversations(new=True)
    #resp = bot.user_details(False)
    #write_data('hist.json', resp)
    #print(json.dumps(resp,indent=5))
    """
    while True:
        msg=input('[*]>>')
        resp = bot.ask(msg)
        print(resp)
        #print(resp)

     """